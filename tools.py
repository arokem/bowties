import os
import time

import numpy as np
from psychopy import visual, core, event

class Params(object):
    """
    The Params class stores all of the parameters needed during the execution
    of ss_run.

    Once a parameter is set, it is protected and cannot be changed, unless it
    is explicitely removed from the _dont_touch variable. 

    Some parameters are set upon initialization from the file 'ss_params.py'

    Others are set through a gui which is generated by the method set_by_gui
    
    """
    def __init__(self, p_file='params'):
        """
        Initializer for the params object.

        Parameters
        ----------

        p_file: string, the name of a parameter file, defaults to 'ss_params'

        """
        self._dont_touch = []
        #The following params are read in from a file with dict p.
        im = __import__(p_file)
        for k in im.p.keys():
            self.__setattr__(k,im.p[k])
            self._dont_touch.append(k)

    def __setattr__(self,name,value):
        """
        
        Overloading __setattr__, such that attributes cant be changed once they
        are set, unless they are explicitely removed from the _dont_touch list.

        """

        if name == '_dont_touch':
            super.__setattr__(self,name,value) 
        elif name in self._dont_touch:
          raise ValueError("Parameter %s is protected, please don't touch!"%name)
        else:
            super.__setattr__(self,name,value)
            self._dont_touch.append(name)
        
    def save(self,f,open_and_close=False):
        """
        This saves the parameters to a text file.

        Takes as an input an already opened file object and returns it in the
        end. Does not open or close the file, unless the variable
        open_and_close is set to True, in which case, the input should be a
        file-name, not a file object

        f is returned either way
        """

        if open_and_close:
            f = file(file_name,'w')
            for k in self.__dict__.keys():
                if k[0]!='_': #Exclude 'private' variables ('_dont_touch')
                    f.write('# %s : %s \n'%(k,self.__dict__[k]))
            f.close()

        else:
            for k in self.__dict__.keys():
                if k[0]!='_': #Exclude 'private' variables ('_dont_touch')
                    f.write('# %s : %s \n'%(k,self.__dict__[k]))
        return f


class Text(object):

    """
    A class for showing text on the screen until a key is pressed 
    """

    def __init__ (self,win,text='Press a key to continue',**kwargs):
        """
        
        Will do the default thing(show 'text' in white on gray background),
        unless you pass in kwargs, which will just go through to
        visual.TextStim (see docstring of that class for more details)

        keys: list. The keys to which you listen for input
        """

        self.win = win
        
        self.text = visual.TextStim(win,text=text,**kwargs)
        
    
    def __call__(self,duration=np.inf):
        """
        Text is shown to the screen, until a key is pressed or until duration
        elapses (default = inf)
        
        """

        clock = core.Clock()
        t=0
        while t<duration: #Keep going for the duration
            t=clock.getTime()

            self.text.draw()
            self.win.flip()

            for key in event.getKeys():
                if key:
                    return

def start_data_file(subject_id, data_dir='./data'):

    """Start a file object into which you will write the data, while making
    sure not to over-write previously existing files """
    
    #Check the data_file:
    
    list_data_dir = os.listdir(data_dir)

    i=1
    this_data_file = '%s_%s_%s_bowties.csv'%(subject_id,
                                                time.strftime('%m%d%Y'),i)

    #This makes sure that you don't over-write previous data:
    while this_data_file in list_data_dir:
        i += 1
        this_data_file='%s_%s_%s_bowties.csv'%(subject_id,
                                                  time.strftime('%m%d%Y'),i)
        
    #Open the file for writing into:
    f = file('%s/%s'%(data_dir, this_data_file),'w')

    #Write some header information
    f.write('# Time : %s#\n'%(time.asctime()))

    return f

def save_data(f,*arg):

    for a in arg[0:-1]:
        f.write('%s,'%a)

    #Don't put a comma after the last one:
    f.write('%s \n'%arg[-1])
    
    return f
